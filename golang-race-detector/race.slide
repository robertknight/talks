The Go Race Detector

11 Jun 2014
Robert Knight
robertknight@gmail.com
http://github.com/robertknight
@robknight_

* Overview

- What is a data race and how can they happen in Go code?
- Using the race detector to find and fix races
- How the race detector works

* Motivation

* Motivation

- Go makes concurrency easy
- ... but also allows you to share data between goroutines
- Sometimes even easy to forget that code may execute concurrently

// TODO - Simple and dumb example with obvious data race
// TODO - More subtle example with less-obvious data race

* Avoiding Races

* Follow Go best practices for communicating

- Use channels to share values between code that may run in different goroutines
- Be familiar with the [[http://golang.org/ref/mem][Go memory model]]

* Go memory model

Provides details on what guarantees Go provides about the order in which events
happen when:

- Variables are read/written within the same or different goroutines
- Goroutines start and finish
- Values are sent or received on channels
- Mutexes are locked or unlocked

.link golang.org/ref/mem

* Using the Race Detector

- Use the `-race` option with `go`build`, or other commands that accept build flags (`go`test`, `go`run`, `go`install`)

	go test -race net/http
	go run -race app.go
	go build -race path/to/package

- Run your app (or tests)
- The race detector will log details of races to console

* Example 1

// TODO - Example showing output from our obvious race

* Example 2

// TODO - Example showing output from our less-obvious race

* Caveats

- Only finds races in _running_ code.
- Therefore testing must exercise _realistic_ workloads
- Performance overhead - CPU cost of runtime library calls and additional memory usage

* How the Race Detector Works

* Detecting Data Races

In order to detect data races, we need to monitor:

- Accesses to memory from different threads
- Operations that impose ordering on memory accesses - either directly (eg. functions in `sync/atomic`) or indirectly (eg. primitives like mutexes, sending values over channels).

Several approaches we could take for this.

* Approach A - Emulate the machine

.image images/fergulator.png 408 399

- Emulate the system - intercept every memory access and function call
- Comprehensive, but _slow_
- Used by valgrind

* Approach B - Rewrite the code

The race detector uses a combination of _compile_time_ instrumentation
and a _runtime_library_.

At compile time, insert calls into the runtime library when "interesting events"
happen:

- Every memory read and write
- Function entrance/exit

Implementation in `cmd/gc/racewalk.c`

* Runtime Components
- Uses the _ThreadSanitizer_ library (originally developed for Chrome)
- The `raceread()` and `racewrite()` functions.
- Packages that provide concurrency primitives (eg. package sync) contain code to instrument operations that impose ordering on memory accesses.

* Memory Access Ordering
- _Happen_before_ relations - If an operation is said to _happen_before_ another then the result must reflect that, even if operations really performed in a different order (eg. due to out-of-order execution by CPU).

Term often used when discussing the _memory_model_ for a language.

eg. from the Go reference: _"A_send_on_a_channel_happens_before_the_corresponding_receive_from_that_channel_completes"_

This guarantee is what makes sharing values via channels safe.

* Memory Access Ordering - Acquire and Release

- Operations that guarantee a _happens_before_ relation between memory accesses come in several flavors. Two common ones are _acquire_ and _release_.
- _Acquire_semantics_ - Applies to operations which _read_ from memory. A read with acquire semantics _happens_before_ any read or write operation which follows it in 'program order' (ie. in the code).
- _Release_semantics_ - Applies to operations which _write_ to memory. Any read or write operation which come before the write with release semantics in program order _happen_before_ the write.

* Implementation - Shadow Memory

- Every 8-byte word of app memory is associated with *N* _shadow_words_
- Each shadow word describes a memory access (read or write) to a subset of the 8-byte word of app memory

	// nb. this is only conceptual, actually a 64-bit word using bitfields in C

	type ShadowWord struct {
		ThreadId int
		Clock int
		IsWrite bool
		Start int // offset with the 8-byte block of app memory
		Size int
	}

- Value of *N* determines how many different accesses can be recorded for each 8-byte word of app memory.

* Implementation - State Machine

Every time a memory access occurs:

- Create new _shadow_word_ is created to represent the current memory access
- Compare with the *N* existing shadow words for the same 8-byte block of memory to find races with earlier accesses.
- Replace one of the existing shadow words

* Implementation - Race Detection

If when comparing the new and existing shadow words we find two memory accesses where:

- The memory regions accessed overlap
- The accesses happened in different threads
- At least one of the accesses is a write
- Neither access _happened_before_ the other

*Houston,*we*have*a*race*

* Summary

- Concurrency is easy in Go
- So are race conditions
- Prevention is better than cure: _Share_memory_by_communicating_ (use channels)
- Use the data race detector

* Further Reading

Usage

.link http://blog.golang.org/race-detector Introducing the Go Race Detector (blog post)
.link https://code.google.com/p/thread-sanitizer/wiki/GoManual ThreadSanitizer Go manual

Implementation

.link https://code.google.com/p/thread-sanitizer/wiki/Algorithm ThreadSanitizer algorithm overview
.link http://preshing.com/20120913/acquire-and-release-semantics/ Primer on Acquire and Release Semantics (useful to understand what it means for one memory access to _happen_before_ another)

